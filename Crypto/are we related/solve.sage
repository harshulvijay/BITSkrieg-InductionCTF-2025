N = 16358742524858989024746530733715520963151096503049475499844772131313900634144226399682520578614077584014275002862632822965229621540435065340281116784386370815429324161742283050731202103907865449759451399602139804982611500302137801891608864979432340886715477587256870771202183324987185743119832773324615711093101683011743064620255562378140344489086343078373998488516048889272966549680630228378089373680970569983571327034624492842068313093361176107522181143795971593171531711087906935350258176653108369262596183611247976165045231094898158749026289902066560871707230661241837636333851833187773843013512855926248400989029
e1 = 41
e2 = 353
a = 555
b = 1938
c1 = 13916708572683061099084186903811462403957849607784088879771357963342182637469431376255994442445342725007784506174839031226365703640683562450144296488454272352023612272836411489333372378939994148065669917693191075791532576574191698006908732122545221144243899531822859227448838910772321259053450053176387142567606197085738405562304338593409066540059145517791179349930313843442164410359821096544582072551321739416600979038138465228657041551937478270099631556683409213722904390604839945550896022849609106234690239931980622917201527921038820977236656929992358795947035871007114128548514966753383451508416073022960551036564
c2 = 10546296767081235754755236416952951397597407571049752969672399532513282148909928879512248840034005606693555434427681371004562837112706926698028625432133719821081717009463967134326356294054368729033691077471501822300789147176744621987169770666043106606381022921389591284002962997104406801190851273015589742999529755654404611877207653205507665136926925798537219298054412533715156130603260848245763192543857814660943715568124834142856985507198474352434725295832674375865303589094742559583739890549785640139897449438593749284595895936625255341228483647134257807176813770970845349240040273492906782870125270953570545477411

# Parameters: modulus, exponents, ciphertexts
R.<X> = Zmod(N)[]
f1 = X**e1 - c1
f2 = (a*X + b)**e2 - c2

def my_gcd(A, B):
    return A.monic() if B == 0 else my_gcd(B, A % B)

g = my_gcd(f1, f2)
print("gcd polynomial degree:", g.degree())
print("gcd:", g)

candidates = []

if g.degree() == 1:
    const = g.coefficients()[0]
    m_rec = (-const) % N
    candidates.append(int(m_rec))
else:
    try:
        fac = g.factor()
        print("factorization of gcd:", fac)
        for facpoly, exp in fac:
            if facpoly.degree() == 1:
                const = facpoly.coefficients()[0]
                m_rec = (-const) % N
                candidates.append(int(m_rec))
    except Exception as exc:
        print("Could not factor gcd in Zmod(N).", exc)

if not candidates:
    print("No linear candidates found from gcd.")
else:
    print("\nCandidates found:", len(candidates))
    valid = []
    for m_rec in candidates:
        ok1 = pow(m_rec, e1, N) == int(c1 % N)
        ok2 = pow((a*m_rec + b) % N, e2, N) == int(c2 % N)
        print("\nCandidate m =", m_rec)
        print(" check c1?", ok1, " check c2?", ok2)
        if ok1 and ok2:
            valid.append(m_rec)
            # print bytes (handle zero)
            if m_rec == 0:
                print(" as bytes: b''")
            else:
                try:
                    bt = Integer(m_rec).to_bytes((m_rec.bit_length()+7)//8, 'big')
                    print(" as bytes:", bt)
                except Exception as e:
                    print(" could not convert to bytes:", e)

    if not valid:
        print("\nNo valid candidate satisfied both ciphertexts.")
    else:
        print("\n=== Valid solutions ===")
        for sol in valid:
            print("m =", sol)
